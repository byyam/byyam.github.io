---
layout: post
title:  "Pion"
date:   2021-09-18 00:00:00
categories: media

---

# Pion是什么

golang实现的webrtc。

## webrtc peerconnection

webrtc里最基本的模块就是peerconnection，代码里经常缩写成pc。

peerconnection对外提供的接口有一部分是On开头的，用于在peerconnection内部发生某事件的回调接口。

使用默认配置新建pc

``` golang
	pc, err := webrtc.NewPeerConnection(config)
```

或使用自定义配置新建pc

``` golang
	peerConnection, err := webrtc.NewAPI(webrtc.WithMediaEngine(m), webrtc.WithInterceptorRegistry(i)).NewPeerConnection(config)
```

NewAPI接口设计使用`Function Option`的编程模式，扩展性好。

``` golang
// webrtc可自定义的引擎和调用链，都定义为私有，只能在初始化时从外部指定
type API struct {
	settingEngine       *SettingEngine // 和ICE，NAT，DTLS等相关的功能，几乎都是标准流程，可定制化的内容很少
	mediaEngine         *MediaEngine // 和pc能力相关的参数，比如codec，extension等
	interceptorRegistry *interceptor.Registry // 和RTP/RTCP包处理相关的功能，比如JitterBuffer，NACK，TWCC等

	interceptor interceptor.Interceptor // Generated per PeerConnection
}
// 对外初始化接口，可灵活扩展
func NewAPI(options ...func(*API)) *API {
	a := &API{interceptor: &interceptor.NoOp{}}

	for _, o := range options {
		o(a)
	}
    ...
}
// 外部可自定义实例化这个成员
func WithInterceptorRegistry(interceptorRegistry *interceptor.Registry) func(a *API) {
	return func(a *API) {
		a.interceptorRegistry = interceptorRegistry
	}
}
```


### ICE




### interceptor

处理RTP/RTCP流的框架，它定义了一套处理数据包的interface，实例化函数接口必须按照指定格式进行调用，这个接口定义为`Interceptor`。

* `BindRTCPReader` 和 `BindRTCPWriter` 处理incoming和outgoing的RTCP包。

* `BindLocalStream` 和 `UnbindLocalStream` 处理outgoing的RTP包。

* `BindRemoteStream` 和 `UnbindRemoteStream` 处理incoming的RTP包。

chain结构体把interceptor串行在一起，并保证interceptor的执行顺序。

streamInfo是处理媒体流的上下文，用于在interceptor之间传递信息。

对外提供registry结构体，在chain上的又一层封装，暴露Add和Build接口。

它提供了一个`type NoOp struct{}`的结构体，任何需要实例化interceptor的结构体都可以继承它。

#### NACK interceptor的实现

`GeneratorInterceptor` 是NACK interceptor对外提供的接口。

``` golang
type GeneratorInterceptor struct {
	interceptor.NoOp // 继承interceptor
	size      uint16 // receiveLog参数
	skipLastN uint16 // receiveLog参数
	interval  time.Duration // 发送RTCP包间隔
	m         sync.Mutex // 这个结构体的锁
	wg        sync.WaitGroup // RTCP writer loop结束才可以关闭的控制
	close     chan struct{} // 控制关闭
	log       logging.LeveledLogger

	receiveLogs   map[uint32]*receiveLog // 记录了接收到的sequence number， key为SSRC
	receiveLogsMu sync.Mutex // receiveLog的map锁
}
```

##### 状态控制

实例化了interceptor的 `UnbindLocalStream`和`BindRemoteStream` 用于处理收到的RTP包， 在收到RTP包时将seq num记录在对应SSRC的receiveLog里。
实例化了interceptor的 `BindRTCPWriter` 用于反馈RTCP包，这里起了一个goroutine异步处理， 按定时器间隔来检查receiveLog。

##### receiveLog实现

receiveLog是interceptor里实现NACK的重要结构体，它记录了一段连续的包是否收到的情况。

``` golang
type receiveLog struct {
	packets         []uint64 // 记录RTP每个包是否收到的bitmap，使用uint64可标识64个包，因此size必须为64的整数倍
	size            uint16 // 可记录连续的RTP包的总数量
	end             uint16 // 记录收到的最后一个seq
	started         bool // 第一个包，初始化上下文
	lastConsecutive uint16 // 记录收到的最后一个连续的seq，查找丢失包时，遍历它到end之间即可
	m               sync.RWMutex // 并发锁
}
```

使用uint64数组当bitmap，记录收到的RTP包，收到时将bit置1，删除时置0。

``` golang
func (s *receiveLog) setReceived(seq uint16) {
	pos := seq % s.size
	s.packets[pos/64] |= 1 << (pos % 64)
}

func (s *receiveLog) delReceived(seq uint16) {
	pos := seq % s.size
	s.packets[pos/64] &^= 1 << (pos % 64)
}

func (s *receiveLog) getReceived(seq uint16) bool {
	pos := seq % s.size
	return (s.packets[pos/64] & (1 << (pos % 64))) != 0
}

```

每收到一个包，刷新连续的最后一个位置`lastConsecutive`和记录seq最大的那个位置`end`。
以便在间隔时间检查需要重传包时，只需遍历从`lastConsecutive`到`end`之间的那段bit是否为0即可。

``` golang
func (s *receiveLog) fixLastConsecutive() {
	i := s.lastConsecutive + 1
	for ; i != s.end+1 && s.getReceived(i); i++ {
		// find all consecutive packets
	}
	s.lastConsecutive = i - 1
}
```

由于bitmap的size标识的是一段时间内需要重传的RTP包，每收到一个新的seq时，需要判断这段buffer是否翻转，并清空从end到seq之间的记录。


#### TWCC interceptor的实现


#### SR/RR interceptor的实现





